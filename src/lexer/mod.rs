//! Лексический анализатор (сканер) для языка MiniC.
//!
//! Этот модуль содержит реализацию лексического анализатора, который
//! преобразует исходный код на языке MiniC в поток токенов.
//!
//! # Архитектура
//!
//! Модуль состоит из трех основных компонентов:
//!
//! 1. **Сканер (`Scanner`)** - основной класс для преобразования текста в токены
//! 2. **Ошибки (`error`)** - типы ошибок лексического анализа
//! 3. **Вспомогательные структуры** - контекст восстановления и т.д.
//!
//! # Основные возможности
//!
//! - Распознавание всех типов токенов языка MiniC
//! - Точное отслеживание позиции (строка, колонка)
//! - Поддержка однострочных и многострочных комментариев
//! - Обработка escape-последовательностей в строках
//! - Восстановление после ошибок с минимальной потерей информации
//! - Поддержка различных форматов окончаний строк (Unix/Windows)
//!
//! # Пример использования
//!
//! ## Базовое использование
//!
//! ```
//! use minic::lexer::Scanner;
//!
//! let source_code = r#"
//! fn main() {
//!     int x = 42;
//!     return x * 2;
//! }
//! "#;
//!
//! let mut scanner = Scanner::new(source_code);
//! let (tokens, errors) = scanner.scan_all();
//!
//! if errors.is_empty() {
//!     for token in tokens {
//!         println!("Найден токен: {}", token);
//!     }
//! } else {
//!     for error in errors {
//!         eprintln!("Ошибка: {}", error);
//!     }
//! }
//! ```
//!
//! ## Пошаговое сканирование
//!
//! ```
//! use minic::lexer::Scanner;
//!
//! let source_code = "x = y + 10;";
//! let mut scanner = Scanner::new(source_code);
//!
//! while !scanner.is_at_end() {
//!     match scanner.next_token() {
//!         Ok(token) => {
//!             if !token.is_eof() {
//!                 println!("Токен: {}", token);
//!             }
//!         }
//!         Err(error) => {
//!             eprintln!("Ошибка лексического анализа: {}", error);
//!         }
//!     }
//! }
//! ```
//!
//! ## Заглядывание вперед
//!
//! ```
//! use minic::lexer::Scanner;
//!
//! let source_code = "if (x > 0) { return 1; }";
//! let mut scanner = Scanner::new(source_code);
//!
//! let first_token = scanner.next_token().unwrap();
//! println!("Первый токен: {}", first_token);
//!
//! let next_token = scanner.peek_token().unwrap();
//! println!("Следующий токен будет: {}", next_token);
//!
//! let second_token = scanner.next_token().unwrap();
//! println!("Второй токен: {}", second_token);
//! ```
//!
//! # Обработка ошибок
//!
//! Сканер реализует стратегию восстановления после ошибок:
//!
//! 1. При обнаружении ошибки возвращается соответствующий `LexerError`
//! 2. Сканер пропускает некорректные символы (обычно 1 символ)
//! 3. Анализ продолжается со следующего допустимого символа
//! 4. Сохраняется информация о пропущенных символах для отладки
//!
//! Это позволяет находить множественные ошибки за один проход.
//!
//! # Производительность
//!
//! - Временная сложность: O(n), где n - длина исходного кода
//! - Память: O(1) дополнительной памяти (не считая результат)
//! - Поддерживает файлы до 1MB (можно увеличить при необходимости)
//!
//! # Ограничения
//!
//! 1. Максимальная длина идентификатора: 255 символов
//! 2. Целые числа ограничены диапазоном i32
//! 3. Не поддерживает Unicode в идентификаторах (только ASCII)
//! 4. Escape-последовательности в строках ограничены базовым набором

mod error;
mod scanner;

pub use error::{ErrorRecovery, LexerError, LexerErrorExt, LexerResult};
pub use scanner::Scanner;

/// Константы, используемые в лексическом анализаторе.
mod constants {
    /// Максимальная длина идентификатора в символах.
    #[allow(dead_code)]
    pub const MAX_IDENTIFIER_LENGTH: usize = 255;

    /// Максимальная длина строкового литерала в символах (без кавычек).
    #[allow(dead_code)]
    pub const MAX_STRING_LENGTH: usize = 65535;

    /// Максимальный размер файла в байтах для обработки.
    #[allow(dead_code)]
    pub const MAX_FILE_SIZE: usize = 1024 * 1024;

    /// Допустимые escape-последовательности.
    #[allow(dead_code)]
    pub const VALID_ESCAPE_SEQUENCES: [char; 6] = ['n', 't', 'r', '\\', '"', '\''];
}
