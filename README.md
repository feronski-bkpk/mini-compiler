# Mini Compiler

**Минимальный компилятор C-подобного языка, написанный на Rust.**

[![Rust](https://img.shields.io/badge/rust-2024-orange?logo=rust)](https://www.rust-lang.org/)

## Оглавление

- [Особенности](#-особенности)
- [Структура проекта](#-структура-проекта)
- [Установка и сборка](#-установка-и-сборка)
- [Быстрый старт](#-быстрый-старт)
- [Использование](#-использование)
- [Тестирование](#-тестирование)
- [Документация](#-документация)
- [Архитектура](#-архитектура)
- [Статус разработки](#-статус-разработки)
- [Команда](#-команда)

## Особенности

### Реализовано
- **Лексический анализатор** - полное распознавание всех типов токенов
- **Препроцессор** - удаление комментариев, макросы, условная компиляция
- **Точное позиционирование** - строка:колонка для всех ошибок
- **Восстановление после ошибок** - продолжение анализа после ошибок
- **Поддержка комментариев** - `//` и `/* */` (включая вложенные)
- **Escape-последовательности** - `\n`, `\t`, `\r`, `\\`, `\"`, `\'`
- **Полный CLI интерфейс** - команды `lex`, `check`, `preprocess`, `test`, `docs`
- **Комплексное тестирование** - 48 тестов (unit + интеграционные)

### Технические характеристики
- **Язык**: Rust 2024 edition
- **Обработка ошибок**: Детальные сообщения с восстановлением
- **Поддержка кодировок**: UTF-8
- **Окончания строк**: Unix (`\n`) и Windows (`\r\n`)

## Структура проекта

```
mini-compiler/
├── src/                      # Исходный код
│   ├── common/               # Общие типы данных
│   │   ├── mod.rs            # Утилиты
│   │   ├── token.rs          # Токены
│   │   └── position.rs       # Позиция в исходном коде
│   ├── lexer/                # Лексический анализатор
│   │   ├── mod.rs            # Основной модуль
│   │   ├── scanner.rs        # Сканер (основная логика)
│   │   └── error.rs          # Ошибки лексического анализа
│   ├── preprocessor/         # Препроцессор (растягивающая цель)
│   │   ├── mod.rs            # Основной модуль препроцессора
│   │   ├── macros.rs         # Таблица макросов
│   │   └── error.rs          # Ошибки препроцессора
│   ├── utils/                # Вспомогательные функции
│   ├── lib.rs                # Точка входа библиотеки
│   └── main.rs               # Точка входа CLI
├── tests/                    # Тестовые файлы
│   ├── lexer/                # Тестовы файлы .src
│   │   ├── invalid/          # Некорректные файлы .src
│   │   └── valid/            # Корректные файлы .src
│   ├── lexer_tests.rs        # Тесты лексического анализатора
│   ├── preprocessor_tests.rs # Тесты препроцессора
│   └── integration_tests.rs  # Интеграционные тесты
├── examples/                 # Демонстративные файлы
├── docs/                     # Документация
│   ├── CHECKLIST.md          # Чек-лист по спринтам
│   └── language_spec.md      # Спецификация языка MiniC
├── Cargo.toml                # Конфигурация Cargo
├── Cargo.lock                # Версии зависимостей
├── README.md                 # Этот файл
└── .gitignore                # Игнорируемые файлы Git
```

## Установка и сборка

### Предварительные требования

- **Rust 1.70 или новее** (рекомендуется использовать [rustup](https://rustup.rs/))
- **Cargo** (менеджер пакетов Rust, устанавливается вместе с Rust)
- **Git** (для клонирования репозитория)

### Установка

```bash
# Клонировать репозиторий
git clone https://github.com/feronski-bkpk/mini-compiler.git
cd mini-compiler

# Собрать проект
cargo build

# Или собрать в режиме релиза (оптимизированная версия)
cargo build --release
```

### Доступные команды сборки

```bash
# Проверка компиляции (без сборки)
cargo check

# Форматирование кода
cargo fmt

# Проверка стиля кода
cargo clippy

# Сборка и запуск
cargo run -- --help

# Только сборка
cargo build
```

## Быстрый старт

### 1. Демонстрация всех возможностей

```bash
# Запуск демонстрационной программы
cargo run --example demo
```

### 2. Полный пайплайн компиляции

```bash
# Создайте тестовый файл
cat > test.src << 'EOF'
#define MAX 100
#define GREETING "Hello, World!"

#ifdef DEBUG
    log("Debug mode enabled");
#endif

fn main() {
    int x = MAX;
    string msg = GREETING;
    
    // Комментарий
    if (x > 0) {
        return x * 2;
    }
    
    return 0;
}
EOF

# 1. Препроцессор
cargo run -- preprocess --input test.src --defines "DEBUG=1" --show

# 2. Лексический анализ
cargo run -- lex --input test.src --verbose

# 3. Проверка синтаксиса
cargo run -- check --input test.src
```

## Использование

### CLI Интерфейс

```bash
# Показать справку
cargo run -- --help

# Показать информацию о компиляторе
cargo run -- info

# Показать спецификацию языка
cargo run -- spec
```

### Основные команды

#### Лексический анализ
```bash
# Анализ файла
cargo run -- lex --input program.src

# Интерактивный режим
cargo run -- lex --interactive

# С выводом в файл
cargo run -- lex --input program.src --output tokens.txt

# Только ошибки
cargo run -- lex --input program.src --quiet

# Остановка при первой ошибке
cargo run -- lex --input program.src --fail-fast
```

#### Препроцессор
```bash
# Обработка препроцессором
cargo run -- preprocess --input program.src --output processed.src

# С макросами
cargo run -- preprocess --input program.src --defines "DEBUG=1" "VERSION=2"

# Показать результат
cargo run -- preprocess --input program.src --show

# Сохранять нумерацию строк
cargo run -- preprocess --input program.src --preserve-lines
```

#### Полный пайплайн
```bash
# Препроцессор + лексический анализ
cargo run -- full --input program.src --defines "FEATURE_ENABLED=1"
```

#### Проверка синтаксиса
```bash
# Проверка файла
cargo run -- check --input program.src

# Строгая проверка
cargo run -- check --input program.src --strict
```

#### Тестирование
```bash
# Запуск всех тестов
cargo test

# С подробным выводом
cargo test -- --nocapture

# Конкретный модуль
cargo test lexer
cargo test preprocessor
cargo test common
```

### Использование как библиотеки

```rust
use minic::{compiler, Preprocessor};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Исходный код с макросами и комментариями
    let source = r#"
        #define MAX 100
        // Комментарий
        fn main() {
            int x = MAX;
            return x * 2;
        }
    "#;
    
    // 1. Препроцессор
    let mut preprocessor = Preprocessor::new(source);
    preprocessor.define("DEBUG", "1")?;
    let processed = preprocessor.process()?;
    
    // 2. Лексический анализ
    let (tokens, errors) = compiler::lexical_analysis(&processed);
    
    if errors.is_empty() {
        println!("Успешно проанализировано {} токенов", tokens.len());
        for token in tokens {
            if !token.is_eof() {
                println!("  {}", token);
            }
        }
    } else {
        println!("Найдено {} ошибок:", errors.len());
        for error in errors {
            println!("  {}", error);
        }
    }
    
    Ok(())
}
```

## Тестирование

### Запуск тестов

```bash
# Все тесты
cargo test

# С подробным выводом
cargo test -- --nocapture

# Конкретный тест
cargo test test_lexer
cargo test test_preprocessor

# Тесты с отладкой
RUST_BACKTRACE=1 cargo test
```

### Статистика тестов

- **Всего тестов**: 48
- **Unit-тесты**: 30 (common, lexer, utils)
- **Интеграционные тесты**: 18
- **Покрытие**: 100% для реализованных функций

### Типы тестов

1. **Unit-тесты** - тестирование отдельных функций и методов
   - `common::position::tests` - работа с позициями
   - `common::token::tests` - создание и проверка токенов
   - `lexer::scanner::tests` - распознавание токенов
   - `preprocessor::tests` - работа препроцессора

2. **Интеграционные тесты** - тестирование взаимодействия модулей
   - `lexer_tests.rs` - полный лексический анализ
   - `preprocessor_tests.rs` - все функции препроцессора
   - `integration_tests.rs` - полный пайплайн

3. **Тестовые примеры** - проверка на реальном коде

## Документация

### Генерация документации

```bash
# Локальная документация
cargo doc --open

# Документация с приватными элементами
cargo doc --document-private-items --open
```

### Ключевые документы

1. **Спецификация языка** - `docs/language_spec.md`
   - Полная грамматика в EBNF
   - Типы данных и операторы
   - Примеры программ

2. **API документация** - автоматически генерируется из doc-комментариев
   - Все публичные функции и структуры
   - Примеры использования
   - Типы ошибок

3. **Тестовые примеры** - директория `tests/`
   - Как использовать библиотеку
   - Граничные случаи
   - Обработка ошибок

## Архитектура

### Текущая реализация

```
      Исходный код
          │
          ▼
   ┌──────────────┐
   │ Препроцессор │  ← #define, #ifdef, комментарии
   └──────────────┘
          │
          ▼
   ┌──────────────┐
   │   Сканер     │  ← Лексический анализ
   └──────────────┘
          │
          ├──────────▶ Поток токенов
          │
          └──────────▶ Сообщения об ошибках
```

### Компоненты системы

#### 1. **Препроцессор** (`src/preprocessor/`)
- Удаление комментариев (`//` и `/* */`)
- Подстановка макросов (`#define`)
- Условная компиляция (`#ifdef`, `#ifndef`, `#endif`, `#else`)
- Обнаружение рекурсии макросов
- Сохранение нумерации строк

#### 2. **Лексический анализатор** (`src/lexer/`)
- **Сканер** - преобразование текста в токены
- **Токены** - 30+ типов (ключевые слова, операторы, литералы)
- **Позиционирование** - точное отслеживание строк и колонок
- **Обработка ошибок** - восстановление после недопустимых символов

#### 3. **Общие типы** (`src/common/`)
- `Token` - токен с типом, лексемой и позицией
- `Position` - позиция в исходном коде (строка, колонка)
- `TokenKind` - перечисление всех типов токенов

#### 4. **CLI интерфейс** (`src/main.rs`)
- 8 команд: `lex`, `check`, `preprocess`, `full`, `test`, `docs`, `info`, `spec`
- 4 формата вывода: `text`, `json`, `minimal`, `verbose`
- Подробная справка и обработка ошибок

## Статус разработки

#### Основные достижения:
- **Лексический анализатор** - полная реализация всех требований
- **Препроцессор** - растягивающая цель выполнена полностью
- **CLI интерфейс** - 8 команд с множеством опций
- **Тестирование** - 48 тестов, 100% покрытие
- **Документация** - полная спецификация

#### Поддерживаемые токены (30+ типов):
- **Ключевые слова**: `if`, `else`, `while`, `for`, `int`, `float`, `bool`, `void`, `return`, `true`, `false`, `struct`, `fn`
- **Литералы**: целые, вещественные, строковые, булевы
- **Операторы**: `+ - * / % == != < <= > >= && || ! = += -= *= /=`
- **Разделители**: `( ) { } [ ] ; , :`

#### Препроцессор:
- Удаление комментариев (однострочные и многострочные)
- Макросы `#define` с подстановкой
- Условная компиляция `#ifdef`/`#ifndef`/`#endif`/`#else`
- Обнаружение рекурсивных макросов
- Сохранение нумерации строк

## Команда

- **Владимир (Feronski)** - Ведущий разработчик

### Как присоединиться?
1. Форкните репозиторий
2. Изучите открытые Issues
3. Создайте ветку для своей задачи
4. Реализуйте изменения с тестами
5. Отправьте Pull Request

## Полезные ссылки

- [Спецификация языка MiniC](docs/language_spec.md)
- [Примеры использования](examples/)
- [Тестовые примеры](tests/)